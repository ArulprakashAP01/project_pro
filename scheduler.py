from apscheduler.schedulers.background import BackgroundScheduler
from datetime import datetime
import pytz
import json
import requests
from packaging import version
from github_utils import check_repository_dependencies, get_github_app, get_github_client

# Language icons and their full names
lang_info = {
    'npm': {'icon': '⚡', 'name': 'Node.js/JavaScript'},
    'pip': {'icon': '🐍', 'name': 'Python'},
    'maven': {'icon': '☕', 'name': 'Java'},
    'cargo': {'icon': '🦀', 'name': 'Rust'},
    'composer': {'icon': '🐘', 'name': 'PHP'},
    'ruby': {'icon': '💎', 'name': 'Ruby'}
}

# Global variable to store previous scan results
previous_scans = {}

def get_health_color(score):
    """Get the appropriate color for health score badge"""
    if score >= 90:
        return 'brightgreen'
    elif score >= 70:
        return 'yellow'
    else:
        return 'red'

def post_report(repo, all_deps, report_body):
    """Post or update the report issue with professional formatting"""
    try:
        issue_title = '📊 Dependency Health Report'
        
        # Add metadata section to the report
        metadata = {
            'repository': repo.full_name,
            'scan_time': datetime.now(pytz.UTC).strftime('%Y-%m-%d %H:%M:%S %Z'),
            'branch': repo.default_branch,
            'last_commit': repo.get_commits()[0].sha[:7]
        }
        
        # Create metadata table
        metadata_table = "| Metadata | Value |\n|----------|-------|\n"
        for key, value in metadata.items():
            metadata_table += f"| **{key.title()}** | `{value}` |\n"
        
        # Add scan summary badges
        total_deps = sum(len(deps) for deps in all_deps.values())
        total_outdated = sum(sum(1 for dep in deps if dep['is_outdated']) for deps in all_deps.values())
        health_score = ((total_deps - total_outdated) / total_deps * 100) if total_deps > 0 else 100
        
        badges = f"""
<div align="center">

![Health Score](https://img.shields.io/badge/Health%20Score-{health_score:.1f}%25-{get_health_color(health_score)})
![Total Dependencies](https://img.shields.io/badge/Dependencies-{total_deps}-blue)
![Outdated](https://img.shields.io/badge/Outdated-{total_outdated}-orange)
![Scan Time](https://img.shields.io/badge/Scan%20Time-{datetime.now(pytz.UTC).strftime('%Y---%m---%d')}-lightgrey)

</div>

---
"""
        
        # Combine all sections
        final_report = f"{badges}\n{metadata_table}\n---\n{report_body}"
        
        # Add action items section
        if total_outdated > 0:
            action_items = """
## 🎯 Recommended Actions

1. **High Priority Updates**
   - Review and update dependencies with major version changes
   - Pay special attention to security-related updates
   - Test thoroughly after each major update

2. **Batch Updates**
   - Group minor and patch updates by ecosystem
   - Update development dependencies during low-traffic periods
   - Run full test suite after batch updates

3. **Security Measures**
   - Check security advisories for outdated packages
   - Prioritize updates with known vulnerabilities
   - Monitor dependency health regularly

4. **Documentation**
   - Update API documentation if needed
   - Note any breaking changes in your changelog
   - Keep track of updated dependency features

## 📅 Next Steps

1. [ ] Review the changes required for each update
2. [ ] Create update branches for testing
3. [ ] Run comprehensive tests
4. [ ] Update documentation
5. [ ] Schedule updates during maintenance window

---
"""
            final_report += action_items
        
        # Add footer
        footer = """
<div align="center">

Generated by [Prosecurelabs](https://prosecurelabs.com) 🤖

</div>
"""
        final_report += footer
        
        # Check for existing issue
        existing_issues = repo.get_issues(state='open')
        existing_issue = None
        for issue in existing_issues:
            if issue.title == issue_title:
                existing_issue = issue
                break
        
        # Create or update issue with labels
        labels = ['dependencies', 'automated-report']
        if health_score < 70:
            labels.append('high-priority')
        if total_outdated > 0:
            labels.append('needs-update')
        
        if existing_issue:
            existing_issue.edit(
                body=final_report,
                labels=labels
            )
            print(f"✅ Updated existing issue #{existing_issue.number} in {repo.full_name}")
        else:
            new_issue = repo.create_issue(
                title=issue_title,
                body=final_report,
                labels=labels
            )
            print(f"✅ Created new issue #{new_issue.number} in {repo.full_name}")
            
    except Exception as e:
        print(f"❌ Error posting report to {repo.full_name}: {str(e)}")

def schedule_dependency_scans():
    """Schedule periodic dependency scans"""
    scheduler = BackgroundScheduler()
    # Run every day at midnight UTC
    scheduler.add_job(scan_all_repositories, 'cron', hour=0, minute=0)
    # Also run every 6 hours
    scheduler.add_job(scan_all_repositories, 'interval', hours=6)
    scheduler.start()
    print("✨ Scheduled dependency scans (daily at midnight UTC and every 6 hours)")

def scan_all_repositories():
    """Scan all repositories with app installation"""
    print("\n🔄 Starting scheduled repository scan")
    scan_time = datetime.now(pytz.UTC)
    
    try:
        # Get all installations
        app = get_github_app()
        installations = app.get_installations()
        
        total_repos = 0
        total_outdated = 0
        total_up_to_date = 0
        
        for installation in installations:
            try:
                g = get_github_client(installation.id)
                if g:
                    repos = g.get_installation_repositories()
                    print(f"📚 Processing {repos.totalCount} repositories for installation {installation.id}")
                    
                    for repo in repos:
                        try:
                            total_repos += 1
                            # Get dependencies
                            all_deps = check_repository_dependencies(repo, installation.id)
                            
                            # Calculate statistics
                            repo_outdated = sum(sum(1 for dep in deps if dep['is_outdated']) for deps in all_deps.values())
                            repo_total = sum(len(deps) for deps in all_deps.values())
                            
                            total_outdated += repo_outdated
                            total_up_to_date += (repo_total - repo_outdated)
                            
                            # Generate and post report
                            report = generate_report(all_deps, repo.name)
                            post_report(repo, all_deps, report)
                            
                        except Exception as e:
                            print(f"❌ Error scanning repository {repo.full_name}: {str(e)}")
            except Exception as e:
                print(f"❌ Error processing installation {installation.id}: {str(e)}")
        
        print(f"\n✨ Scan completed at {scan_time.strftime('%Y-%m-%d %H:%M:%S %Z')}")
        print(f"📊 Summary:")
        print(f"- Total repositories scanned: {total_repos}")
        print(f"- Total outdated dependencies: {total_outdated}")
        print(f"- Total up-to-date dependencies: {total_up_to_date}")
        
    except Exception as e:
        print(f"❌ Error in scheduled scan: {str(e)}")

def generate_report(all_deps, repo_name):
    """Generate a professional dependency report"""
    scan_time = datetime.now(pytz.UTC)
    
    # Start with report header
    body = f"""# 📊 Dependency Health Report
    
## Overview
- **Repository**: `{repo_name}`
- **Scan Time**: {scan_time.strftime('%Y-%m-%d %H:%M:%S %Z')}
- **Report Type**: Automated Dependency Analysis

## 📈 Summary
"""
    
    # Calculate statistics
    total_deps = sum(len(deps) for deps in all_deps.values())
    total_outdated = sum(sum(1 for dep in deps if dep['is_outdated']) for deps in all_deps.values())
    total_up_to_date = total_deps - total_outdated
    
    if total_deps > 0:
        health_score = (total_up_to_date / total_deps) * 100
        body += f"""- **Total Dependencies**: {total_deps}
- **Up-to-date**: {total_up_to_date} ({health_score:.1f}% healthy)
- **Outdated**: {total_outdated} ({100-health_score:.1f}% need attention)

## 🔍 Detailed Analysis

"""
    else:
        body += "No dependencies found in supported package managers.\n\n"
        return body
    
    has_outdated = False
    
    # Add ecosystem-specific health scores
    body += "### Health Scores by Ecosystem\n\n"
    for ecosystem, deps in all_deps.items():
        if deps:
            outdated = sum(1 for dep in deps if dep['is_outdated'])
            up_to_date = len(deps) - outdated
            if len(deps) > 0:
                health = (up_to_date / len(deps)) * 100
                icon = lang_info[ecosystem]['icon']
                name = lang_info[ecosystem]['name']
                status = "✅" if health == 100 else "⚠️" if health >= 70 else "🚨"
                body += f"- {status} **{name}** ({icon}): {health:.1f}% healthy ({up_to_date}/{len(deps)} up-to-date)\n"
    
    body += "\n## 📦 Outdated Dependencies\n\n"
    
    # Track major updates separately
    major_updates = []
    
    for ecosystem, deps in all_deps.items():
        outdated_deps = [dep for dep in deps if dep['is_outdated']]
        if outdated_deps:
            has_outdated = True
            lang = lang_info[ecosystem]
            body += f"### {lang['icon']} {lang['name']}\n"
            body += "| Package | Current | Latest | Update Type | Registry | Security Risk |\n"
            body += "|---------|----------|---------|--------------|-----------|-------------|\n"
            
            # Sort by update type (Major > Minor > Patch)
            def get_update_type_priority(dep):
                try:
                    current = version.parse(dep['current_version'])
                    latest = version.parse(dep['latest_version'])
                    if latest.major > current.major:
                        return 0  # Major update - highest priority
                    elif latest.minor > current.minor:
                        return 1  # Minor update
                    else:
                        return 2  # Patch update
                except:
                    return 3  # Unknown - lowest priority
            
            sorted_deps = sorted(outdated_deps, key=get_update_type_priority)
            
            for dep in sorted_deps:
                name = dep['name']
                current = dep['current_version']
                latest = dep['latest_version']
                
                # Determine update type and its emoji
                try:
                    current_ver = version.parse(current)
                    latest_ver = version.parse(latest)
                    if latest_ver.major > current_ver.major:
                        update_type = "🚨 Major"
                        major_updates.append(f"- `{name}` ({current} → {latest})")
                    elif latest_ver.minor > current_ver.minor:
                        update_type = "⚠️ Minor"
                    else:
                        update_type = "ℹ️ Patch"
                except:
                    update_type = "❓ Unknown"
                
                # Add registry links
                if ecosystem == 'npm':
                    registry = f"[npm](https://www.npmjs.com/package/{name})"
                elif ecosystem == 'pip':
                    registry = f"[PyPI](https://pypi.org/project/{name}/)"
                elif ecosystem == 'maven':
                    registry = f"[Maven](https://mvnrepository.com/artifact/{name})"
                elif ecosystem == 'cargo':
                    registry = f"[crates.io](https://crates.io/crates/{name})"
                elif ecosystem == 'composer':
                    registry = f"[Packagist](https://packagist.org/packages/{name})"
                elif ecosystem == 'ruby':
                    registry = f"[RubyGems](https://rubygems.org/gems/{name})"
                
                # Determine security risk
                if update_type == "🚨 Major":
                    security_risk = "🔴 High"
                elif update_type == "⚠️ Minor":
                    security_risk = "🟡 Medium"
                else:
                    security_risk = "🟢 Low"
                
                body += f"| `{name}` | `{current}` | `{latest}` | {update_type} | {registry} | {security_risk} |\n"
            
            body += "\n"
    
    if not has_outdated:
        body += "✅ All dependencies are up to date!\n\n"
    else:
        if major_updates:
            body += "\n## ⚠️ High Priority Updates\n\n"
            body += "The following dependencies have major version updates and may include breaking changes:\n\n"
            body += "\n".join(major_updates)
            body += "\n\n"
    
    return body 